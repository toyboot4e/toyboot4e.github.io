<!DOCTYPE html>
<html lang="ja"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Wave Function Collapse の解説 - toybeam</title><meta name="description" content="devlog of toyboot4e"/><link rel="stylesheet" href="/style/simple.min.css"/><link rel="stylesheet" href="/style/style.css"/><link rel="stylesheet" href="/style/prism.css"/><script type="text/javascript" src="/style/style.js"></script><script type="text/javascript" async="" src="/style/prism.js"></script><!-- MathJax --><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script></head><body><header role="banner"><h1>Wave Function Collapse の解説</h1><p>Nov 22, 2024</p><nav role="navigation"><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></nav></header><main role="main"><h2 id="背景"><a href="#背景">背景</a></h2><p>
5 年前のブログの復刻版です。迷宮生成アルゴリズム "WFC" を紹介します。<br>
</p>

<ul><li>オリジナル: <a href="https://github.com/mxgmn/WaveFunctionCollapse">mxgmn/WaveFunctionCollapse</a> (23.4k stars)<br></li>
<li>参考実装: <a href="https://github.com/gridbugs/wfc">gridbugs/wfc</a><br></li>
<li>僕の実装: <a href="https://github.com/toyboot4e/wfc.cs/">toyboot4e/wfc.cs</a><br></li>
</ul>
<h3 id="WFC とは何か"><a href="#WFC とは何か">WFC とは何か</a></h3><p>
WFC のリポジトリにはドラマチックなデモがありました。画像や迷宮をランダム生成しています。これは一体何なのでしょうか？　Web 検索すると、波動関数だエントロピーだと謎めいた解説が目につき、謎は深まるばかりです。<br>
</p>


<figure>
<img src="http://i.imgur.com/X3aNDUv.gif" alt="X3aNDUv.gif"><br>

<figcaption><span class="figure-number">Figure 1: </span>何が起きているのか？！</figcaption>
</figure>


<p>
そんな中、実際に WFC を使ったゲームとしては <a href="https://store.steampowered.com/app/333640/Caves_of_Qud/">Caves of Qud</a> がありました。開発者のプレゼンテーション <a href="https://www.youtube.com/watch?v=U03XXzcThGU">Data-Driven Engines of Qud and Sproggiwood</a> には大いに影響を受けましたから、 WFC にも時間を割いて理解してみることにしました。<br>
</p>
<h3 id="なぜ WFC に熱狂したのか"><a href="#なぜ WFC に熱狂したのか">なぜ WFC に熱狂したのか</a></h3><p>
WFC のスター数は <strong>23.4k</strong> です。 Minecraft の ECS (<a href="https://github.com/skypjack/entt">EnTT</a>) ですら 10.3k ですから、ゲーム開発界隈の中でも特別に注目を浴びたリポジトリと言えます。<br>
</p>

<p>
僕自身、 WFC の万能性に熱狂しました。マップ生成のアルゴリズムは、通常 1 種類の地形に特化しています。部屋が通路で繋がれた迷宮、入り組んだ渓谷、開けた荒野、等々の地形は、それぞれ専用のアルゴリズムにより生成されます。それぞれのアルゴリズムは、せいぜいパラメータの調整しかできませんから、とても汎用的とは呼べません。<br>
</p>

<p>
ところが WFC は『入力と類似したマップを生成する』というアイデアですから、新しい地形を作り出すには、新しい入力データを与えるだけで済みます。まるで魔法のアルゴリズム！<br>
</p>
<h3 id="注意！"><a href="#注意！">注意！</a></h3><p>
先に水を差してしまいますが、 WFC は万能ではありません。結局のところ、個別の専用アルゴリズムを容易した方が無難だと思います。<br>
</p>

<ul><li>マップ生成には非常に長い時間がかかります<br></li>
<li>WFC の生の出力はゲームマップ向きではありません (足場が一繋がりではないなど)<br></li>
</ul>
<h2 id="WFC の『モデル』"><a href="#WFC の『モデル』">WFC の『モデル』</a></h2><p>
<a href="https://github.com/mxgmn/WaveFunctionCollapse">WFC</a> の正体は『制約充足問題』であると言われています。グリッドに NxN サイズのパターンを敷き詰めて、かつ制約に違反しない配置をランダムに見つけることで、入力データと類似した出力を生成します。<br>
</p>

<p>
……と言っても、まったくピンと来ないと思います。より具体的に、ここでは一番面白いモデル、 Overlapping Model を紹介します。<br>
</p>
<h3 id="1. パターン生成"><a href="#1. パターン生成">1. パターン生成</a></h3><p>
WFC のコア・アルゴリズムは、 <code>Solver</code> です。 <code>Solver</code> は、与えられた <code>Pattern</code> 列を <code>Pattern</code> 同士の 『接続性』 (<code>AdjacencyRule</code>) を満たすようにランダムに配置します。<br>
</p>

<div class="org-src-container">
<pre><code class="src language-haskell">Model: Input -&gt; ([Pattern], AdjacencyRule)
Solver: ([Pattern], AdjacencyRule) -&gt; Map
</code></pre>
</div>

<p>
以下では単純な例でデータの流れを紹介します。<br>
</p>
<h4 id="User input = map"><a href="#User input = map">User input = map</a></h4><p>
<code>Model</code> は、入力として与えられたマップから、 <code>[Pattern]</code> と <code>AdjacencyRule</code> を作ります。例として、 3x3 のマップを入力とします。<br>
</p>

<pre><code class="example">..#
.##
.#.
</code></pre>

<p>
『パタン』のサイズを 2x2 として、入力から 2x2 のパタンを展開します。<br>
</p>

<pre><code class="example">..  .#
.#  ##

.#  ##
.#  #.
</code></pre>

<p>
これらの回転 (rotation) や裏返し (flipping/reflection) も考えてみます（2x2 サイズでは、回転だけでも十分です）。<br>
</p>

<pre><code class="example">..  ..  #.  .#
.#  #.  ..  ..

.#  #.  ##  ##
##  ##  #.  .#    &lt;-- (duplicated patterns)

.#  ..  #.  ##
.#  ##  #.  ..
</code></pre>

<p>
重複を除くと、 12 個のパタンができました。 <code>Solver</code> はこのパタンをランダムに配置してマップを生成しますが、その際に以下の制約を設けます。<br>
</p>
<h4 id="制約"><a href="#制約">制約</a></h4><p>
Overlapping model では次の制約を課します。<br>
</p>

<blockquote>
<p>
出力から展開できるパタンの集まりは、入力から展開したパタンの部分集合である。<br>
</p>
</blockquote>

<p>
たとえば、次のような出力が得られたとします。<br>
</p>

<pre><code class="example">...
.#.
###
</code></pre>

<p>
これを 2x2 に分けていくと、次のように 4 パタンに分かれます。これらは、どれも入力から展開できるパタンです。<br>
</p>

<pre><code class="example">(output)                  (patterns)

                            ..  ..
  ...        extract        .#  #.
  .#.    ---------------&gt;
  ###    &lt;---------------   .#  #.
             overlap        ##  ##
</code></pre>

<p>
これが overlapping model における制約です。 Local similarity とも呼ばれます。出力のどの部分 (NxN パタン) も入力のある部分 (NxN パタン) と一致します。<br>
</p>
<h4 id="Example"><a href="#Example">Example</a></h4><p>
僕が <a href="https://github.com/toyboot4e/wfc.cs">実装</a> した WFC に、迷宮らしき入力を与えてみます。 <code>#</code> が壁、 <code>.</code> が床を表します。<br>
</p>

<p>
<strong>Input (16x16)</strong><br>
</p>

<div class="org-src-container">
<pre><code class="src language-txt">###.########.###
###.#####......#
#.....###......#
#.....###......#
#...............
......###......#
#.....###......#
##.######......#
##.########.####
##.########.####
##......##....##
........##......
##............##
##......##....##
##......####.###
###.########.###
</code></pre>
</div>

<p>
パタンサイズを 3x3 として走らせと、次のような出力が得られました。入力と似た風になっています。この出力から任意の 3x3 のパタンを取り出すと、それは上の入力マップからも (回転や鏡写しで) 見つけることができます。<br>
</p>

<p>
<strong>Output (36x36)</strong><br>
</p>

<div class="org-src-container">
<pre><code class="src language-txt">...........##.##.##########.###.####
...........##.......#######.###.####
....................####.........###
...........##.......####.........##.
#.###.###.###.####.######.###.#####.
#.###.###.###.####.######.###.######
#.###.###.....##...######.......####
................................##..
.......##.....##...######...........
.......####.####...######.......##..
#.###.#####.####...##..########.##..
#.###.####...########..########.###.
...##.####...############..####.###.
...##.####...##..########..##.......
#.###.#########..##...###..##.......
#.###.#############...###..##.......
#..##.###....######...###..#########
...##.................##############
#......##....#######.#############..
#..###.##.##.#######.#############..
##.###.##.##.#####.....######...##..
##.##..##.......##.....######...##..
...##...........##.....######.......
#......###.###.###..............##..
#..###.###.###.###.....#######.#####
######.###.###.###.....#######.#####
######.###..##.#############.....###
............##.#############........
........##..##...##..#######.....##.
........##.......##..########.#####.
............###.###..########.#####.
........##..###.###..####.......###.
........##.......##..####.......###.
####.#####..##...##..####.......###.
####.#########...########.......###.
##....########...########...........
</code></pre>
</div>

<p>
なお、床は 1 繋がりにはなっておらず、孤立した部分もあります。 <strong>ゲームのマップとしては、そのまま使うことはできません</strong> 。<br>
</p>

<blockquote>
<p>
<a href="http://www.cavesofqud.com/">Caves of Qud</a> は WFC で円などの形 (segment) を埋めてから、孤立した部分を無くすプロセスを挟んでいるようです。<br>
</p>
</blockquote>

<p>
先ほどの出力を円形に切り出してみると、意味深になります。荒野に配置すれば魔物の巣として使えそうです。<br>
</p>

<div class="org-src-container">
<pre><code class="src language-txt">             .......####
          ..........####...
         ..##.......####....
       ##.###.####.######.###.
      ###.###.####.######.###.#
     .###.....##...######.......
    ............................#
    ...##.....##...######........
   ....####.####...######.......##
  ###.#####.####...##..########.##.
  ###.####...########..########.###
  .##.####...############..####.###
 ..##.####...##..########..##.......
 .###.#########..##...###..##.......
 .###.#############...###..##.......
 ..##.###....######...###..#########
 ..##.................##############
 ......##....#######.#############..
 ..###.##.##.#######.#############..
 #.###.##.##.#####.....######...##..
 #.##..##.......##.....######...##..
 ..##...........##.....######.......
 ......###.###.###..............##..
  .###.###.###.###.....#######.####
  ####.###.###.###.....#######.####
  ####.###..##.#############.....##
   .........##.#############......
    ....##..##...##..#######.....
    ....##.......##..########.###
     .......###.###..########.##
      ..##..###.###..####......
       .##.......##..####.....
         #..##...##..####...
          ####...########..
             #...#######
</code></pre>
</div>
<h2 id="制約充足問題の解き方"><a href="#制約充足問題の解き方">制約充足問題の解き方</a></h2><p>
<code>Solver</code> は <code>Model</code> が定義した <code>AdjacencyRule</code> を満たすように <code>Pattern</code> 配置のグリッドを作ります。と言っても確実な計算方法があるわけではなく、『試して上手くいったら採用』という形になります。ただし『こうすればよく上手くいく』という『発見的手法 (heuristic)』に頼ります。<br>
</p>

<blockquote>
<p>
ここから解説が投げ槍になります！<br>
</p>
</blockquote>
<h3 id="The solving loop"><a href="#The solving loop">The solving loop</a></h3><p>
出力グリッドを『未確定』の状態で初期化してから、 <code>Solver</code> は走ります:<br>
</p>

<div class="org-src-container">
<pre><code class="src language-csharp">public class Solver {
    // ~~
    public bool run() {
        while (this.numRemainingCells &gt; 0) {
            var cell = selectNextCellToDecidePattern(); 
            var pattern = selectStiilAvailablePatternForCell(cell); 
            decidePatternOfCell(cell, pattern); 
            this.numRemainingCells -= 1;
            propagateRemovals(); 
        } 
    }
}
</code></pre>
</div>

<ul><li>パタンが未確定のセルを 1 つ選びます (後述の heuristic を使用)。<br></li>
<li>そのセルにまだ配置可能なパタンを選びます。<br></li>
<li>このセルを選んだパタンで確定し、その他のパタンをセルの配置可能パタンから <code>remove</code> します。<br></li>
<li>パタンが配置不能になった (<code>remove</code> した) 事による影響を伝播 (<code>propagate</code>) させます。すなわち、配置可能パタンのキャッシュを更新します。<br></li>

<li>ループ開始へ戻り、再び次のセルが選ばれます。すべてのセルのパタンを確定させたら終了です。<br></li>
</ul>

<p>
ただし、配置可能なパタン数が 0 となるセルが出た場合は、失敗です。そのときは、今は最初からやり直すことにしておきます (後述) 。<br>
</p>

<p>
各手順を詳しく解説します。<br>
</p>
<h3 id="1. Selecting "the most constrained" cell (pattern weight heuristic)"><a href="#1. Selecting "the most constrained" cell (pattern weight heuristic)">1. Selecting "the most constrained" cell (pattern weight heuristic)</a></h3><p>
未確定のセルから、次にパタンを確定させる0セルを選びます。このときヒューリスティックとして、最も "制約された" セルを選びます。具体的には、パタンが <code>source</code> に現れた回数をそのパタンの重み付けとし、重みの総和が最も小さなセルを選びます。すなわち重複したパタンの出現回数を増やします。<br>
</p>

<p>
効率のため、 <code>BinaryHeap</code> に重みづけされたセルを入れて 1 つずつ取り出します:<br>
</p>

<ul><li>セル毎に、重さのキャッシュを作ります<br></li>

<li>セルの重み付けが更新されたとき、そのセルを新たに <code>BinaryHeap</code> に入れます (これで古いデータよりも先に出てくるようになります)<br></li>

<li>重みの総和に小さな乱数を足すことで、重みの等しいパタンの選出をランダムにします<br></li>
</ul>
<h3 id="2. Selecting a pattern"><a href="#2. Selecting a pattern">2. Selecting a pattern</a></h3><p>
選んだセルから、配置可能なパタンをランダムに選び、確定させます。そのためには、重み付けされたセルの配列を、一種の <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a> とみなして、乱数を使って選びます。これによりパタンの重み付けが選択確率に反映されます。<br>
</p>

<p>
なお配置可能なパタン数が 0 の場合は <strong>失敗</strong> なので注意します (contradiction) 。<br>
</p>
<h3 id="3. Constraint propagation"><a href="#3. Constraint propagation">3. Constraint propagation</a></h3><p>
セルのパタンを確定すると、そのセルの周囲に配置可能なパタンが減ります。この変化を追跡するためのステップです。<br>
</p>
<h4 id="Enabler counts"><a href="#Enabler counts">Enabler counts</a></h4><p>
まず、それぞれのセルについて、 4 方向に向けて、隣接可能なパタン (enabler) の数を追跡することにします。<br>
</p>

<p>
<code>EnablerCounts</code> は、考えとしては <code>Grid&lt;Dictionary&lt;Direction&gt;&gt;</code> に相当します。<br>
</p>
<h4 id="Removals of patterns"><a href="#Removals of patterns">Removals of patterns</a></h4><p>
あるパタンを <code>remove</code> したときに、その影響を、 <code>EnablerCounts</code> の変化として周囲のセルに伝播させます。なお、 <code>enabler</code> の数が 0 になる方向が出た場合、そのパタンは <code>remove</code> されます。したがって、パタンの除去と <code>EnablerCounts</code> の更新は再帰的になり得ます。<br>
</p>
<h3 id="4. Repeating until solved"><a href="#4. Repeating until solved">4. Repeating until solved</a></h3><p>
手順 1. に戻り、次のセルを選びます。やがて全セルを『確定』させるか、どこかのセルに配置可能なパタンが無くなって『失敗』します。<br>
</p>
<h2 id="Wrapping up"><a href="#Wrapping up">Wrapping up</a></h2><p>
簡単 &amp; 強力な新規の自動生成アルゴリズム 『Wave FunCtion collapse』 を解説する記事でした。入力と類似した出力を生成する万能は、プロトタイピングに適しています。しかし、出力に特定の制限を加えるのは難しいため、使い方に工夫が必要です。また、大きなマップを作る場合、パフォーマンスが問題になるかもしれません。<br>
</p>
</main><footer role="contentinfo"><p>Styled with <a href="https://simplecss.org/">Simple.css</a></p><div><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></div></footer></body></html>
