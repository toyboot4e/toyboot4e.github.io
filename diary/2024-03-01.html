<!DOCTYPE html>
<html lang="ja"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>ABC 343 / 16 キー操作 - toybeam</title><meta name="description" content="devlog of toyboot4e"/><link rel="stylesheet" href="/style/simple.min.css"/><link rel="stylesheet" href="/style/style.css"/><link rel="stylesheet" href="/style/prism.css"/><script type="text/javascript" async="" src="/style/prism.js"></script><!-- MathJax --><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script></head><body><header role="banner"><h1>ABC 343 / 16 キー操作</h1><p>Mar  1, 2024</p><nav role="navigation"><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></nav></header><main role="main">
<h2 id="ABC 343"><a href="#ABC 343">ABC 343</a></h2><p>
<a href="https://atcoder.jp/contests/abc343">ABC 343</a> に参加しました。 4 完 (A ~ D) でした。<br>
</p>

<h3 id="A 問題"><a href="#A 問題"><a href="https://atcoder.jp/contests/abc343/tasks/abc343_a">A 問題</a></a></h3><p>
問題分を素直にコードに落としました:<br>
</p>

<div class="org-src-container">
<pre><code class="src language-hs">main :: IO ()
main = do
  (!a, !b) &lt;- ints2
  print . head . filter (/= a + b) $ [0 .. 9]
</code></pre>
</div>

<h3 id="B 問題"><a href="#B 問題"><a href="https://atcoder.jp/contests/abc343/tasks/abc343_b">B 問題</a></a></h3><p>
グリッドを <code>V.Vector (U.Vector Int)</code> の形で読むと各行処理がしやすいです。 <code>findIndices</code> を使ってスマートに解答できました:<br>
</p>

<div class="org-src-container">
<pre><code class="src language-hs">main :: IO ()
main = do
  !n &lt;- ints1
  !xs &lt;- V.replicateM n intsU
  V.forM_ xs $ \vec -&gt;
    putLnBSB . unwordsBSB . U.map succ $ U.findIndices (== 1) vec
</code></pre>
</div>

<h3 id="C 問題"><a href="#C 問題"><a href="https://atcoder.jp/contests/abc343/tasks/abc343_c">C 問題</a></a></h3><p>
\(x^3\) が回文であるか判定します。回文の判定においては、文字列として比較するか、 10 進数の各桁に分解して比較することができます。<br>
</p>

<h3 id="D 問題"><a href="#D 問題"><a href="https://atcoder.jp/contests/abc343/tasks/abc343_d">D 問題</a></a></h3><p>
<a href="https://cpprefjp.github.io/reference/set/multiset.html">multiset</a> に対応するデータ型を持っていると楽できます。ハイライト:<br>
</p>

<div class="org-src-container">
<pre><code class="src language-diff-hs diff-highlight">main :: IO ()
main = do
  (!n, !t) &lt;- ints2
  !iws0 &lt;- U.replicateM t (first pred &lt;$&gt; ints2)

  let !ms0 = (1, IM.singleton 0 n)
  !ws &lt;- UM.replicate n (0 :: Int)
  (\f -&gt; U.foldM'_ f ms0 iws0) $ \ms (!i, !dw) -&gt; do
+    !w &lt;- UM.read ws i
+    UM.write ws i (w + dw)
+    let ms' = (incMS (w + dw) . decMS w) ms
    print $ fst ms'
    return ms'
</code></pre>
</div>

<p>
<code>Mutliset</code> の <a href="https://github.com/toyboot4e/toy-lib/blob/main/src/Data/MultiSet.hs">僕の実装はこれ</a> です。<br>
</p>

<h3 id="E 問題"><a href="#E 問題"><a href="https://atcoder.jp/contests/abc343/tasks/abc343_e">E 問題</a></a></h3><p>
小学校でやったような 3 集合のベン図を書くのですが、実装がバグっていてダメでした。<br>
</p>

<h3 id="F 問題"><a href="#F 問題"><a href="https://atcoder.jp/contests/abc343/tasks/abc343_f">F 問題</a></a></h3><p>
平方分割を試みました。実装が間に合わず、 upsolve しようにも TLE して完敗です。<br>
</p>

<ul><li><a href="https://atcoder.jp/contests/abc343/submissions/50845371">tanakh さんの提出 (1,775 ms)</a><br></li>
<li><a href="https://atcoder.jp/contests/abc343/submissions/50837854">ゼットさんの提出 (=1,994 ms)</a><br></li>
</ul>

<h3 id="その他メモ"><a href="#その他メモ">その他メモ</a></h3><ul><li><a href="https://hackage.haskell.org/package/primitive-0.9.0.0/docs/Control-Monad-Primitive.html">PrimMonad</a> は『 <code>IO</code> または <code>ST</code> 』 よりもちょっと便利<br>
たとえば <code>StateT s IO</code> に <code>PrimMonad</code> が実装されているため、 <code>liftIO</code> を書かずに済みます。同様に、 <code>STRef</code> や <code>IORef</code> よりも <a href="https://hackage.haskell.org/package/primitive-0.9.0.0/docs/Data-Primitive-MutVar.html">MutVar</a> の方が少し便利です。<br></li>

<li><code>Heap</code> vs <code>IntSet</code><br>
<code>Heap</code> においてはキーが重複した要素も格納できます。<br></li>

<li><code>IntSet</code> の高速な 2 分割<br>
<a href="https://www.stackage.org/haddock/lts-21.6/containers-0.6.7/Data-IntSet.html#v:spanAntitone">spanAntitone</a> を知りました。<br></li>
</ul>

<h2 id="キーボード操作"><a href="#キーボード操作">キーボード操作</a></h2><p>
キー数を減らす方向に舵を切って情報収集しています。<br>
</p>

<h3 id="34 キー操作"><a href="#34 キー操作">34 キー操作</a></h3><p>
Keyball 44 を 34 キーで操作するようになりました。 34 はかなり余裕のあるキー数で (そんな馬鹿な) 、余るキーも多いです。<br>
</p>

<p>
34 キーの代表的なキーボードは <a href="https://github.com/davidphilipbarr/Sweep">Sweep</a> です。操作は柔軟で見栄えも良く、この辺りがエンドゲームかと思います。キーボード界の <code>i3</code> かもです。<br>
</p>

<p>
34 キーでは装飾キーの数が足りないため、 Tap-Hold によって装飾キーを入力します。これはファームウェアの機能です。<br>
</p>

<h3 id="16 キー操作"><a href="#16 キー操作">16 キー操作</a></h3><h4 id="ファームウェアの主な機能"><a href="#ファームウェアの主な機能">ファームウェアの主な機能</a></h4><p>
16 キー操作を理解するため、 <a href="https://zmk.dev/docs/development/documentation">ZMK ファームウェア</a> の一部機能をメモしました。<br>
</p>

<h5 id="Layers"><a href="#Layers"><a href="https://zmk.dev/docs/behaviors/layers">Layers</a></a></h5><p>
レイアウトを切り替える機能です。切り替え方式は主に 3 つです。<br>
</p>

<ol><li>トグル<br></li>
<li>ホールドしている間のみ<br></li>
<li>入力後、次の 1 キーのみ (スマホの Shift キー相当)<br></li>
</ol>

<h5 id="Combos"><a href="#Combos"><a href="https://zmk.dev/docs/features/combos">Combos</a></a></h5><p>
複数キーの同時押しを別キーとして解釈する機能です。<br>
</p>

<blockquote>
<p>
Ben Villack 氏は combo のファンでは無いらしく、複数キーを素早く入力 (rolling) したときに誤作動すると述べていました。<br>
</p>
</blockquote>

<h5 id="Hold-Tap"><a href="#Hold-Tap"><a href="https://zmk.dev/docs/behaviors/hold-tap">Hold-Tap</a></a></h5><p>
長押しを別キーとして解釈する機能です。 Hold/Tap の優先度を調整できるっぽいです。<br>
</p>

<h4 id="Piano (Ben Villack)"><a href="#Piano (Ben Villack)">Piano (Ben Villack)</a></h4><p>
事前知識を蓄えたところで、 Ben Villack 氏の <a href="https://www.youtube.com/watch?v=5RN_4PQ0j1A">Has Your Keyboard Got Too Many Keys?</a> を観ました。 16 キーのキーボード操作を、レイヤ切り替えのみで (combo 無しで) 実現しています。<br>
</p>

<h5 id="Home-Row Mods"><a href="#Home-Row Mods">Home-Row Mods</a></h5><p>
<a href="https://precondition.github.io/home-row-mods">A guide to home row mods</a><br>
</p>

<p>
ASDFGHJKL といった home ポジションの row キーの長押しを modifier キーとして解釈する方式です。 Piano も同様に、キーの長押しで装飾キーの入力やレイヤ切り替えができます。<br>
</p>

<h5 id="レイヤ切り替え"><a href="#レイヤ切り替え">レイヤ切り替え</a></h5><p>
主にスマホのシフトキー相当のレイヤ切り替えを行っています。たとえば左手キーの長押しで記号レイヤに入り、右手で記号を入力すると、元のレイヤに戻ってきます。このように、主に <strong>2 回の打鍵で 1 つのキーを入力する</strong> のが Ben Villack 式だと理解しました。<br>
</p>

<p>
<a href="https://youtu.be/5RN_4PQ0j1A?si=Oi9f-ieUHe8Fn5SG&amp;t=731">レイヤ切り替えが見れる部分 (12:11)</a><br>
</p>

<h5 id="装飾キーを押せるのか？"><a href="#装飾キーを押せるのか？">装飾キーを押せるのか？</a></h5><p>
装飾キーは、ほぼレイヤ 1 にしか無いようです。他のレイヤのキーに装飾キーを付与する方法が気になります。<br>
</p>

<ul><li>実は他のレイヤでも hold が装飾キーになる？<br></li>
<li>装飾キーもロックされる (スマホの shift キー相当) ？<br></li>
</ul>

<h3 id="8 キー操作"><a href="#8 キー操作">8 キー操作</a></h3><p>
<a href="https://artsey.io/">ARTSEY (artsey.io)</a> は combo (複数キーの同時押し) を活かして 8 キーによる入力を実現しています。僕が隻腕になったら、フリック入力の次にこれを試すと思います。<br>
</p>

<p>
<a href="https://www.youtube.com/watch?v=dicYf7OiS3Q">Introduction: ARTSEY One Handed Keyboard - Youtube</a><br>
</p>

<h3 id="まとめ"><a href="#まとめ">まとめ</a></h3><p>
34 キー操作を習得し、 16 キー操作 (Piano), 8 キー操作 (ARTSEY) をざっと見ました。未知の部分が小さくなり、そこそこ満足しました。 16 キー操作は自分でも試してみたいかもです。<br>
</p>

<h2 id="Misc"><a href="#Misc">Misc</a></h2><h3 id="Miniaxe"><a href="#Miniaxe">Miniaxe</a></h3><p>
<a href="https://kagizaraya.jp/en/products/miniaxe">Miniaxe</a> の基盤を破壊してしまいました。今年一番落ち込みました。<br>
</p>

<p>
今後は先に基盤にハンダを塗ることにします。再注文しました。<br>
</p>
</main><footer role="contentinfo"><p>Styled with <a href="https://simplecss.org/">Simple.css</a></p><div><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></div></footer></body></html>
