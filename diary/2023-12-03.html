<!DOCTYPE html>
<html lang="ja"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>ABC 331, PAST 17 / 累積和 - toybeam</title><meta name="description" content="devlog of toyboot4e"/><link rel="stylesheet" href="/style/simple.min.css"/><link rel="stylesheet" href="/style/style.css"/><link rel="stylesheet" href="/style/prism.css"/><script type="text/javascript" async="" src="/style/prism.js"></script><!-- MathJax --><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script></head><body><header role="banner"><h1>ABC 331, PAST 17 / 累積和</h1><p>Dec  3, 2023</p><nav role="navigation"><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></nav></header><main role="main">
<h2 id="競技プログラミング"><a href="#競技プログラミング">競技プログラミング</a></h2><h3 id="訓練"><a href="#訓練">訓練</a></h3><p>
Keyball 44 で寿司打に取り組み、 15,000 円以上のスコアを安定して出せるようになった。<br>
</p>

<h3 id="PAST 17"><a href="#PAST 17">PAST 17</a></h3><p>
第 17 回アルゴリズム実技検定を受験した。 11 / 15 問を解き、中級認定だった。<br>
</p>

<h3 id="ABC 331"><a href="#ABC 331">ABC 331</a></h3><p>
<a href="https://atcoder.jp/contests/abc331">ABC 331</a> に参加した。 5 完 (A ~ E) だった。<br>
</p>

<p>
<a href="https://atcoder.jp/contests/abc331/tasks/abc331_a">A 問題</a> では繰り上がりが 1 桁の場合、 2 桁の場合、無い場合で分岐した。<br>
</p>

<p>
<a href="https://atcoder.jp/contests/abc331/tasks/abc331_b">B 問題</a> は全探索で解いた。 \(N \le 100\) と小さく枝刈りは必要無かった。<br>
</p>

<p>
<a href="https://atcoder.jp/contests/abc331/tasks/abc331_c">C 問題</a> では制約 \(A_i \le 10^6\) を突いてセグメント木を使ってしまった。 \(A_i \le 10^9\) のように変域が大きな場合も、座標圧縮してセグメント木を使ったと思う。<br>
</p>

<p>
累積和と比べてセグメント木を簡単に感じる理由は、 1. 可変配列を使用するため構築が用意、2. 添字アクセスが素直 の 2 点にあった。<br>
</p>

<p>
改めて <a href="https://atcoder.jp/contests/abc331/submissions/48157545">座標圧縮と累積和で解いてみた</a> 。 1 次元累積和にアクセスするための <code>+!</code> 演算子を追加したため、添字アクセスも単純になった……かも。<br>
</p>

<p>
<a href="https://atcoder.jp/contests/abc331/tasks/abc331_d">D 問題</a> では 2 次元累積和を書いた。自作ライブラリに 2 次元累積和を計算する <code>csum2D</code> と、 2 次元累積和の取得演算子 <code>@+!</code> を追加した。<br>
</p>

<p>
デバッグ時には、グリッドを <code>stderr</code> に表示するユーティリティが役立った。<br>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>入力のグリッドはこういうもの</label><pre><code class="src language-txt">001
110
010
</code></pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>デバッグ用関数呼び出し</label><pre><code class="src language-hs">  let !csum = csum2D $ mapIV (bool 0 (1 :: Int)) gr
  let !_ = dbgGridN 3 csum
</code></pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>2 次元累積和のデバッグ表示</label><pre><code class="src language-txt">  0   0   0   0
  0   0   0   1
  0   1   2   3
  0   1   3   4
</code></pre>
</div>

<p>
<a href="https://atcoder.jp/contests/abc331/tasks/abc331_e">E 問題</a> では主菜を全探索し、副菜は降順ソートして有効な組み合わせが出るまで線型探索した。たかだか L 回しか無効な組み合わせは現れないため、最大 \(N + K\) 回の探索で済む。いわゆる『鳩の巣原理』だった。<br>
</p>

<p>
<a href="https://atcoder.jp/contests/abc331/tasks/abc331_f">F 問題</a> では回文の判定にローリングハッシュを使う過去問を思い出した。ローリングハッシュの実装を見る限りセグメント木に載りそうで良問の雰囲気だったが、もう実装する気力が無かった。<br>
</p>

<h2 id="Misc"><a href="#Misc">Misc</a></h2><h3 id="Haskell 本: 進捗 15 %"><a href="#Haskell 本: 進捗 15 %">Haskell 本: 進捗 15 %</a></h3><p>
最近 <code>ST</code> モナド関連でコンパイルエラーが取れず青ざめた。この辺をすべてカバーするのは難しい。大して書けることは無いと諦めの気持ちになってきた。<br>
</p>

<h3 id="Emacs"><a href="#Emacs">Emacs</a></h3><p>
<code>dired</code> に <code>vidir</code> 的な一括リネーム機能があることを知った。大活躍している。<br>
</p>
</main><footer role="contentinfo"><p>Styled with <a href="https://simplecss.org/">Simple.css</a></p><div><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></div></footer></body></html>