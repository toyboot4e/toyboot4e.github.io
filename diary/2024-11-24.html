<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ABC 381 - toybeam</title>
    <meta name="description" content="devlog of toyboot4e" />
    <link rel="stylesheet" href="/style/simple.min.css" />
    <link rel="stylesheet" href="/style/style.css" />
    <link rel="stylesheet" href="/style/prism.css" />
    <script type="text/javascript" src="/style/style.js"></script>
    <script type="text/javascript" async="" src="/style/prism.js"></script>
    <!-- MathJax -->
    <script
      type="text/javascript"
      async=""
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"
    ></script>
  </head>
  <body>
    <header role="banner">
      <h1>ABC 381</h1>
      <p>Nov 22, 2024</p>
      <nav role="navigation">
        <a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a>
      </nav>
    </header>
    <main role="main">
      <h2 id="ABC 381"><a href="#ABC 381">ABC 381</a></h2>
      <p>
        <a href="https://atcoder.jp/contests/abc381">ABC 381</a>
        に参加しました。今回はダメダメでした。<br />
      </p>

      <table>
        <caption class="t-above">
          <span class="table-number">Table 1:</span>
          Diff 予想
        </caption>

        <colgroup>
          <col class="org-left" />

          <col class="org-right" />

          <col class="org-right" />

          <col class="org-right" />

          <col class="org-left" />

          <col class="org-left" />

          <col class="org-left" />
        </colgroup>
        <thead>
          <tr>
            <th scope="col" class="org-left">問題</th>
            <th scope="col" class="org-right">A 問題</th>
            <th scope="col" class="org-right">B 問題</th>
            <th scope="col" class="org-right">C 問題</th>
            <th scope="col" class="org-left">D 問題</th>
            <th scope="col" class="org-left">E 問題</th>
            <th scope="col" class="org-left">F 問題</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="org-left">提出</td>
            <td class="org-right">AC</td>
            <td class="org-right">AC</td>
            <td class="org-right">AC</td>
            <td class="org-left">AC</td>
            <td class="org-left">-</td>
            <td class="org-left">-</td>
          </tr>

          <tr>
            <td class="org-left">予想 diff</td>
            <td class="org-right">40</td>
            <td class="org-right">400</td>
            <td class="org-right">300</td>
            <td class="org-left">1,000</td>
            <td class="org-left">&#xa0;</td>
            <td class="org-left">&#xa0;</td>
          </tr>

          <tr>
            <td class="org-left">実際 diff</td>
            <td class="org-right">31</td>
            <td class="org-right">52</td>
            <td class="org-right">209</td>
            <td class="org-left">921</td>
            <td class="org-left">&#xa0;</td>
            <td class="org-left">&#xa0;</td>
          </tr>
        </tbody>
      </table>
      <h3 id="A 問題">
        <a href="#A 問題"><a href="https://atcoder.jp/contests/abc381/tasks/abc381_a">A 問題</a></a>
      </h3>
      <p>
        文字列 <code>s</code> 全体が正規表現 <code>1+/2+</code> とマッチし、かつ
        <code>/</code> が文字列の中央にあるか答えよ。前と後ろからマッチさせて調べました。<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-haskell">solve :: StateT BS.ByteString IO ()
solve = do
  !n &lt;- int'
  !s &lt;- BS.unpack &lt;$&gt; line'
  let lf = length $ takeWhile (== '1') s
  let lb = length . takeWhile (== '2') $ reverse s
  printYn $ lf == lb &amp;&amp; lf + lb + 1 == n
</code></pre>
      </div>
      <h3 id="B 問題">
        <a href="#B 問題"><a href="https://atcoder.jp/contests/abc381/tasks/abc381_b">B 問題</a></a>
      </h3>
      <p>
        文字列 <code>s</code> 全体が正規表現 <code>(a-z)\1</code> とマッチし、かつ同じ文字が
        <code>2</code> 回のみ現れるか判定せよ。愚直に判定しましたが、やや実装が重い。<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-haskell">solve :: StateT BS.ByteString IO ()
solve = do
  !s &lt;- BS.unpack &lt;$&gt; line'
  let n = length s
  let b1 = all (even . length) $ group s
  let cnt = U.accumulate (+) (U.replicate 26 (0 :: Int)) $ U.map ((,1) . subtract (ord 'a') . ord) $ U.fromListN n s
  let b2 = U.all (`elem` [0, 2]) cnt
  printYn $ even n &amp;&amp; b1 &amp;&amp; b2
</code></pre>
      </div>
      <h3 id="C 問題">
        <a href="#C 問題"><a href="https://atcoder.jp/contests/abc381/tasks/abc381_c">C 問題</a></a>
      </h3>
      <p>
        文字列 <code>s</code> の中で <code>111/222</code> と同じ形の最長連続部分列を求めよ。 RLE
        に変換し <code>zipWith3</code> で見るのが簡単そうです。<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-haskell">solve :: StateT BS.ByteString IO ()
solve = do
  !n &lt;- int'
  !s &lt;- line'
  let rle = U.fromList . map ((,) &lt;$&gt; head &lt;*&gt; length) . group $ BS.unpack s
  let res
        | U.length rle &lt; 3 = bool 0 1 $ BS.elem '/' s
        | otherwise = U.maximum $ U.zipWith3 f rle (U.tail rle) (U.tail (U.tail rle))
        where
          f ('1', !n1) ('/', 1) ('2', !n2) = 2 * min n1 n2 + 1
          f _ ('/', !_) _ = 1
          f _ _ _ = 0
  printBSB res
</code></pre>
      </div>
      <h3 id="D 問題">
        <a href="#D 問題"><a href="https://atcoder.jp/contests/abc381/tasks/abc381_d">D 問題</a></a>
      </h3>
      <p>
        文字列 <code>s</code> から B
        問題と同じ条件を満たす最長の連続部分列を求めよ。基本的なアイデアは尺取り法ですが、綺麗に落とし込めなかったため、クシャクシャの再帰ループで通しました。<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-haskell">solve :: StateT BS.ByteString IO ()
solve = do
  !n &lt;- int'
  !xs &lt;- U.map pred &lt;$&gt; intsU'

  let run :: Int -&gt; Int -&gt; Int -&gt; Seq.Seq Int -&gt; IS.IntSet -&gt; [Int] -&gt; Int
      run !accMax !lastC !acc !cPop !is [] = accMax
      run !accMax !lastC !acc !cPop !is (c1 : c2 : rest)
        | c1 == c2 =
            if IS.member c1 is
              then
                let loop :: Int -&gt; IS.IntSet -&gt; Seq.Seq Int -&gt; (Int, IS.IntSet, Seq.Seq Int)
                    loop !acc' !is' Seq.Empty = error "unreachable"
                    loop !acc' !is' (c Seq.:&lt;| popRest)
                      | c == c1 = {- insert c to the end -} (acc', is', popRest Seq.|&gt; c1)
                      | otherwise = loop (acc' - 2) (IS.delete c is') popRest
                    (!acc', !is', !cPop') = loop acc is cPop
                 in run accMax c1 acc' cPop' is' rest
              else run (max accMax (acc + 2)) c1 (acc + 2) (cPop Seq.|&gt; c1) (IS.insert c1 is) rest
      run !accMax !cLast !_ !_ !_ (c : rest)
<span id="coderef-4-1" onmouseover="CodeHighlightOn(this,'jump-coderef-4-1');" onmouseout="CodeHighlightOff(this,'jump-coderef-4-1');" class="coderef-off"><a href="#coderef-4-1">        | c == cLast = run accMax c 2 (Seq.singleton c) (IS.singleton c) rest -- <span class="coderef-anchor">1</span></a></span>
        | otherwise = run accMax c 0 Seq.Empty IS.empty rest

  printBSB $ run 0 (-1) 0 Seq.Empty IS.empty (U.toList xs)
</code></pre>
      </div>

      <ul>
        <li>
          <a
            href="#coderef-4-1"
            id="jump-coderef-4-1"
            class="coderef"
            onmouseover="CodeHighlightOn(this,'coderef-4-1');"
            onmouseout="CodeHighlightOff(this, 'coderef-4-1');"
            ><span class="coderef-anchor">1</span></a
          >: <code>aaxxx</code> のような文字列があった場合、末尾の
          <code>xx</code> からリスタートします。<br />
        </li>
      </ul>
      <h3 id="E 問題">
        <a href="#E 問題"><a href="https://atcoder.jp/contests/abc381/tasks/abc381_e">E 問題</a></a>
      </h3>
      <p>
        XXXX (伏せ字)
        で解けるらしいですが、未だにイメージできていません。久しぶりに公式解説を観ようかと思います。<br />
      </p>
      <h3 id="F 問題">
        <a href="#F 問題"><a href="https://atcoder.jp/contests/abc381/tasks/abc381_f">F 問題</a></a>
      </h3>
      <h2 id="ac-library-hs">
        <a href="#ac-library-hs"><code>ac-library-hs</code></a>
      </h2>
      <p>
        <code>string</code>, <code>math</code>, <code>internal_math</code> を移植しました。残るは
        <code>modint</code> と <code>convolution</code> です (<a
          href="https://github.com/toyboot4e/ac-library-hs/issues/1"
          >#1</a
        >) 。 11 月中に移植可能です。<br />
      </p>

      <p>
        <a href="https://en.wikipedia.org/wiki/Barrett_reduction">Barrett reduction</a> の実装で
        <a href="https://hackage.haskell.org/package/wide-word">wide-word</a> の 128 bit 整数
        (<code>Word128</code>) に依存しようと思います。言語アップデートの Discord でも
        <a href="https://hackage.haskell.org/package/wide-word">wide-word</a>
        の追加を提案しました。<br />
      </p>

      <p>
        <code>MagicHash</code> 無しだと <code>Barrett</code> や
        <code>ModInt</code>
        のパフォーマンスが悪い気がします。ベンチマークテストを用意して、リリース前にヘルプを出そうと思います。<br />
      </p>
    </main>
    <footer role="contentinfo">
      <p>Styled with <a href="https://simplecss.org/">Simple.css</a></p>
      <div><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></div>
    </footer>
  </body>
</html>
