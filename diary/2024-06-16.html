<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ABC 358 / Z Function / Suffix Array / SKK - toybeam</title>
    <meta name="description" content="devlog of toyboot4e" />
    <link rel="stylesheet" href="/style/simple.min.css" />
    <link rel="stylesheet" href="/style/style.css" />
    <link rel="stylesheet" href="/style/prism.css" />
    <script type="text/javascript" async="" src="/style/prism.js"></script>
    <!-- MathJax -->
    <script
      type="text/javascript"
      async=""
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"
    ></script>
  </head>
  <body>
    <header role="banner">
      <h1>ABC 358 / Z Function / Suffix Array / SKK</h1>
      <p>Jun 16, 2024</p>
      <nav role="navigation">
        <a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a>
      </nav>
    </header>
    <main role="main">
      <h2 id="ABC 358"><a href="#ABC 358">ABC 358</a></h2>
      <p><a href="https://atcoder.jp/contests/abc358">ABC 358</a> に参加しました。<br /></p>

      <table>
        <caption class="t-above">
          <span class="table-number">Table 1:</span>
          Diff 予想
        </caption>

        <colgroup>
          <col class="org-left" />

          <col class="org-right" />

          <col class="org-right" />

          <col class="org-right" />

          <col class="org-right" />

          <col class="org-left" />

          <col class="org-left" />

          <col class="org-left" />
        </colgroup>
        <thead>
          <tr>
            <th scope="col" class="org-left">問題</th>
            <th scope="col" class="org-right">A 問題</th>
            <th scope="col" class="org-right">B 問題</th>
            <th scope="col" class="org-right">C 問題</th>
            <th scope="col" class="org-right">D 問題</th>
            <th scope="col" class="org-left">E 問題</th>
            <th scope="col" class="org-left">F 問題</th>
            <th scope="col" class="org-left">G 問題</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="org-left">予想</td>
            <td class="org-right">1</td>
            <td class="org-right">2</td>
            <td class="org-right">500</td>
            <td class="org-right">900</td>
            <td class="org-left">1,800</td>
            <td class="org-left">1,600</td>
            <td class="org-left">2,400</td>
          </tr>

          <tr>
            <td class="org-left">実際</td>
            <td class="org-right">11</td>
            <td class="org-right">43</td>
            <td class="org-right">273</td>
            <td class="org-right">393</td>
            <td class="org-left">1,397</td>
            <td class="org-left">2,098</td>
            <td class="org-left">1,737</td>
          </tr>
        </tbody>
      </table>

      <h3 id="A 問題">
        <a href="#A 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_a">A 問題</a></a>
      </h3>
      <p>
        <code>interact</code>
        の罠がよく分かる問題です。入力ファイルの末尾に改行文字があるのでしょう。<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-hs">main=interact b;b"AtCoder Land\n"="Yes";b _="No"
</code></pre>
      </div>

      <p>注意点として改行文字 (LF) が 2 バイト (CRLF?) になりがちです。<br /></p>

      <blockquote>
        <p>
          <a
            href="https://qiita.com/kotatsugame/items/184bfd63d9b21f214475#atcoder%E3%81%A7%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B4%E3%83%AB%E3%83%95%E3%82%92%E3%81%99%E3%82%8B%E3%81%AB%E3%81%82%E3%81%9F%E3%81%A3%E3%81%A6"
            >AtCoderでコードゴルフをするにあたって</a
          ><br />
        </p>

        <p>submitページから直接提出すると、改行文字は2Byteとカウントされます。<br /></p>
      </blockquote>

      <p>
        <code>;</code> で区切ったほうが面倒がありません。 Kotatsugame さんは改行文字を 1
        バイトにして提出するブラウザ拡張を使っています。<br />
      </p>

      <h3 id="B 問題">
        <a href="#B 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_b">B 問題</a></a>
      </h3>
      <p><code>scanl</code> の問題です。<br /></p>

      <div class="org-src-container">
        <pre><code class="src language-hs">main=interact$unwords.map show.f.map read.words;f(n:a:t)=tail$scanl(\x y-&gt;max x y+a)0 t
</code></pre>
      </div>

      <p>
        コードゴルフが目的でなければ <code>scanl'</code> を使います。
        <code>vector</code> パッケージにおいては <code>postscanl'</code> を使えば
        <code>tail</code> する必要がありません。<br />
      </p>

      <h3 id="C 問題">
        <a href="#C 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_c">C 問題</a></a>
      </h3>
      <p>
        Bit 全探索と bitset の問題でした。 Bit mask の和を取るときは、 <code>sum</code> ではなく
        <code>foldl' (.|.) (0 :: Int)</code> を使わねばなりません……<br />
      </p>

      <h3 id="D 問題">
        <a href="#D 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_d">D 問題</a></a>
      </h3>
      <p>
        2 つのリストをソートしてマッチさせて行くのが良さそうです (<a
          href="https://atcoder.jp/contests/abc358/submissions/54573835"
          >cojna さんの提出</a
        >) 。<br />
      </p>

      <p>僕は multiset でズルをしてしまいました。<br /></p>

      <h3 id="E 問題">
        <a href="#E 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_e">E 問題</a></a>
      </h3>
      <p>
        DP
        でした。選んだ文字の長さに注目し、その内訳を忘れ去ることで、状態数を大幅に削減し緩和が効きます。良問ですね。<br />
      </p>

      <p>Upsolve します。<br /></p>

      <h3 id="F 問題">
        <a href="#F 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_f">F 問題</a></a>
      </h3>
      <p>hogee<br /></p>

      <h3 id="G 問題">
        <a href="#G 問題"><a href="https://atcoder.jp/contests/abc358/tasks/abc358_g">G 問題</a></a>
      </h3>
      <p>hogee<br /></p>

      <h2 id="Z Function"><a href="#Z Function">Z Function</a></h2>
      <p>
        文字列に苦手意識があります。特に文字列のアルゴリズムは全容が見えて来ません。困難は実装せよということで、
        <a href="https://cp-algorithms.com/">Algorithms for Competitive Programming</a>
        を写経しました。<br />
      </p>

      <p>
        <a href="https://cp-algorithms.com/string/z-function.html"
          >Z-function - Algorithms for Competitive Programming</a
        ><br />
      </p>

      <p>
        このサイトは初見に厳し目ですが、読めば分かるように書いてあって高印象……好印象です。以下は自分用メモです。<br />
      </p>

      <h3 id="\(O(N^2)\) 実装"><a href="#\(O(N^2)\) 実装">\(O(N^2)\) 実装</a></h3>
      <p>Z 関数 (配列) の定義を以下とします:<br /></p>

      <p>\[ z[i] := \mathcal{lcp}(s[0:], s[i:]) \]<br /></p>

      <p>愚直に計算します:<br /></p>

      <div class="org-src-container">
        <pre><code class="src language-hs">-- | \(O(\max(N, M))\) Longest common prefix calculation. \(z[0] := |s|\).
lcpOf :: BS.ByteString -&gt; BS.ByteString -&gt; Int
lcpOf bs1 bs2 = length . takeWhile id $ BS.zipWith (==) bs1 bs2

-- | \(O(N^2)\) Z function calculation. \(z[0] := |s|\).
zOfNaive :: BS.ByteString -&gt; U.Vector Int
zOfNaive bs = U.generate (BS.length bs) z
  where
    -- z 0 = 0
    z i = lcpOf bs (BS.drop i bs)
</code></pre>
      </div>

      <h3 id="\(O(N)\) 実装"><a href="#\(O(N)\) 実装">\(O(N)\) 実装</a></h3>
      <p>
        \(s\) と接尾辞 (\(s[1:], s[2:], \dots\)) のマッチの内、最も右端までマッチした範囲を
        <em>z-box</em> と呼んで保持します。 z-box 内の \(i\) に対する \(z[i]\) の計算には \(z[i']
        (i' < i)\) の計算結果を利用できます:<br />
      </p>

      <figure>
        <img
          src="./img/2024-06-16-z-function.png"
          alt="2024-06-16-z-function.png"
          width="371px"
        /><br />
      </figure>

      <p>
        実装中は z-box を状態に持って <code>constructN</code> したくなりました。しかし
        <code>constructN</code> が引数に取るのは純粋関数です。やはり
        <a
          href="https://github.com/cojna/iota/blob/d6b5d9cbb38de5dea2c151663776858a413abde5/src/Data/ByteString/ZAlgorithm.hs"
          >cojna さんの実装</a
        >
        と同様に可変配列を手動管理しました。
        <a
          href="https://github.com/toyboot4e/toy-lib/blob/ef9b371ce11a2dc8dd0195c6bd0c615f345770da/src/Data/ByteString/ZFunction.hs"
          >僕の実装 (ZFunction.hs)</a
        ><br />
      </p>

      <h4 id="\(O(N)\) になるお気持ち">
        <a href="#\(O(N)\) になるお気持ち">\(O(N)\) になるお気持ち</a>
      </h4>
      <p>
        z-box の右端は単調増加します。 LCP の trivial
        解による文字比較の回数は、マッチした場合・マッチしなかった場合がそれぞれ高々
        <code>n</code> 回となります。よって \(O(n)\) で計算できています。そんなお気持ちです。<br />
      </p>

      <h4 id="Quickcheck"><a href="#Quickcheck">Quickcheck</a></h4>
      <p>愚直解と比較しました。<br /></p>

      <h4 id="Library Checker"><a href="#Library Checker">Library Checker</a></h4>
      <p>
        <a href="https://judge.yosupo.jp/submission/215154">Z Algorithm - Library Checker</a> が
        <a href="https://judge.yosupo.jp/submission/215154">22 ms</a> でした。さすが \(O(N)\)
        です。<br />
      </p>

      <p>まだ使い方は知らず、エアプです。<br /></p>

      <h2 id="Suffix array"><a href="#Suffix array">Suffix array</a></h2>
      <p>
        <a href="https://cp-algorithms.com/string/suffix-array.html"
          >Suffix Array - Algorithms for Competitive Programming</a
        ><br />
      </p>

      <p>
        <a href="https://atcoder.jp/contests/practice2/tasks/practice2_i"
          >ACL I - Number of Substrings</a
        >
        で立ちはだかるデータ構造です。以下は自分用メモです。<br />
      </p>

      <h3 id="\(O(N^2 \log N)\) 実装">
        <a href="#\(O(N^2 \log N)\) 実装">\(O(N^2 \log N)\) 実装</a>
      </h3>
      <p>
        Suffix array <code>sa</code> は、文字列 <code>s</code> の全 suffix をソートした後の添字
        <code>i'</code> を元の suffix の番号 <code>i</code> に写します。愚直に実装しました:<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-hs">saOfNaive :: BS.ByteString -&gt; U.Vector Int
saOfNaive bs =
  U.convert
    . V.map fst
    . V.modify (VAI.sortBy (comparing snd))
    $ V.generate n (\i -&gt; (i, BS.drop i bs))
  where
    n = BS.length bs
</code></pre>
      </div>

      <p>
        以降、 <code>i</code> と <code>i'</code> の空間の違いを強く意識することが重要です。<br />
      </p>

      <h3 id="\(O(N \log N)\) 実装"><a href="#\(O(N \log N)\) 実装">\(O(N \log N)\) 実装</a></h3>
      <p>
        <a href="https://cp-algorithms.com/string/suffix-array.html"
          >Suffix Array - Algorithms for Competitive Programming</a
        ><br />
      </p>

      <p>写経しました。分割された困難のメモです:<br /></p>

      <ul>
        <li>
          文字列 <code>s</code> の <code>i</code> 番目の suffix とは (復習)<br />
          例: <code>s := abc</code> に対する <code>[abc, bc c] !! i</code> です。<br />
        </li>

        <li>
          メタ文字 <code>$</code><br />
          長さの異なる文字列の辞書順比較は、『最小の文字』を表すメタ文字
          <code>$</code> を補完して解釈できます。たとえば <code>ab</code> と
          <code>abcd</code> の比較は <code>ab$$ &lt; abcd</code> です。<br />
        </li>

        <li>
          <code>p[i]</code>: 計数ソート (counting sort) による順列の生成 (<code>sa</code>
          の生成過程)<br />
          等しい部分列の出現回数を記録し、累積和を取ります。累積和を基に、それぞれの部分列に
          <code>0</code> ~ <code>(n - 1)</code> の番号を割り当てます (順列を生成します) 。<br />
        </li>

        <li>
          <code>c[i]</code>: Class, equivalent class<br />
          等しい部分列に等しい値 (辞書順で小さいものから <code>0, 1, 2..</code>)
          を与えます。以降は元の文字列を忘れ、 class をベースにソートします。<br />
        </li>

        <li>
          ダブリング<br />
          文字列の末尾にメタ文字 <code>$</code> を挿入します。これに対し長さ \(2^i (i \in [0, 1, ..,
          \lceil \log_2 N \rceil])\) の循環部分列のソートを求めることで、 suffix array
          が求まります。<br />
        </li>

        <li>
          賢いソート<br />
          ダブリング時のソートは工夫により \(O(N)\) になります。接尾辞の長さを 2
          倍にするとき、右側半分でのソートは既に実施されているため、左側半分で stable sort
          すれば良いです。計数ソートは stable sort になるように注意します (添字の割当の際に reverse
          します) 。<br />
        </li>
      </ul>

      <p>積み重ねが凄くて面白いですね。<br /></p>

      <h4 id="QuickCheck"><a href="#QuickCheck">QuickCheck</a></h4>
      <p>愚直解と比較しました。<br /></p>

      <h4 id="Library checker"><a href="#Library checker">Library checker</a></h4>
      <p>
        <a href="https://judge.yosupo.jp/problem/suffixarray">Suffix Array - Library Checker</a> が
        <a href="https://judge.yosupo.jp/submission/215153">234 ms</a> でした。 \((O(N))\) 実装は 2
        ~ 7 倍速くなります。<br />
      </p>

      <h3 id="\(O(N)\) 実装 (スキップ)">
        <a href="#\(O(N)\) 実装 (スキップ)">\(O(N)\) 実装 (スキップ)</a>
      </h3>
      <p>
        SA-IS (suffix array induced sorting) が \(O(N)\) で強いらしいです。 \(O(N)\)
        でなければ間に合わない問題もしばしばあるようですが、大変らしいので飛ばします。<br />
      </p>

      <h3 id="LCP 配列 (Kasai's algorithm)">
        <a href="#LCP 配列 (Kasai's algorithm)">LCP 配列 (Kasai's algorithm)</a>
      </h3>
      <p>
        Suffix array と LCP 配列を併用すると、 suffix trie よりも効率が良いと評判のようです。 Suffix
        trie のことは知らないので、 trie との関連付けは一旦忘れることにします。<br />
      </p>

      <h4 id="LCP 配列とは"><a href="#LCP 配列とは">LCP 配列とは</a></h4>
      <p>
        多数の \(lcp(s[sa[i]:], s[sa[j]:])\) クエリへの応答を考えます。 \(s[sa[i]:], s[sa[j]:]\)
        を直接比較して LCP を求めたいところですが、任意の \(i, j\) に対して LCP
        を高速で求める工夫が必要です。<br />
      </p>

      <p>
        ここで \(\mathcal{lcp}[i] := \mathcal{lcp}(s[sa[i]:], s[sa[i+1]:])\) を用いて
        \(\mathcal{lcp}(i, j) = \min \{ \mathcal{lcp}[k, k+1] ) \}_{k \in [i .. j)}\) のようです。
        \(\mathcal{lcp}\) 配列の添字が辞書順ソート後の接尾辞列に対する添字であることを考えると、
        \(s[sa[i]:]\) から \(s[sa[j]:]\) まで徐々に \(s[sa[j]]\)
        に向かって文字列が編集されていくように見えます。実際 \(\mathcal{lcp}(s[sa[i]:], s[sa[k]:])\)
        は \(k\) が増加するにつれて単調減少します。ここで \(k \in [i .. j - 1]\) の範囲で
        <code>min</code> 演算子で LCP を畳み込むことで \(lcp(s[sa[i]:], s[sa[j]:])\)
        の計算を代替できるようです:<br />
      </p>

      <div class="org-src-container">
        <label class="org-src-name"
          ><span class="listing-number">Listing 1: </span>min で LCP を畳み込む</label
        >
        <pre><code class="src language-txt">                      LCP      LCP (畳み込み)
1:   a b a b a b
     *-*-*-*          4        4
2:   a b a b c d
     *                1        min 4 1 = 1
3:   a c a b c d
     *-*-*-*-*        5        min 1 5 = 1
4:   a c a b c e
</code></pre>
      </div>

      <p>(証明が欲しい)<br /></p>

      <p>
        また重要な事実として suffix array 上で隣接した 2 項の LCP が最も大きく、間隔を広げると LCP
        は広義単調減少します。このことから次の Kasai's algorithm を導けます。<br />
      </p>

      <h4 id="Kasai's algorithm (\(O(N)\))">
        <a href="#Kasai's algorithm (\(O(N)\))">Kasai's algorithm (\(O(N)\))</a>
      </h4>
      <p>
        LCP 配列生成の方法は \(O(N)\)
        <a href="http://alumni.cs.ucr.edu/~rakthant/cs234/01_KLAAP_Linear%20time%20LCP.PDF"
          >Kasai's algorihm</a
        >
        を採用します。より高速な実装も多数ある (<a
          href="https://qiita.com/kgoto/items/9e28e37b8a4b15ea7230"
          >LCP配列の構築アルゴリズムたち</a
        >) ようですが、 \(O(N)\) の時点で十分高速です。<br />
      </p>

      <p>
        Kasai's algorithm では最長の suffix から順に LCP 配列の値を確定させます。 (元の添字 →
        ソート後の添字) を \(\mathcal{sa}^{-1}\) として<br />
      </p>

      \begin{aligned} \mathcal{sa}[\mathcal{sa}^{-1}[i]] &:= i \\
      \mathcal{lcp}[\mathcal{sa}^{-1}[i]] &:= \mathcal{lcp}(s[i:],
      s[\mathcal{sa}[\mathcal{sa}^{-1}[i]+1]:]) \\ \mathcal{lcp}[\mathcal{sa}^{-1}[i+1]] &\ge
      \mathcal{lcp}[\mathcal{sa}^{-1}[i]] - 1 \\ \end{aligned}

      <p>
        2 行目は \(s[(i+1):], s[(\mathcal{sa}^{-1}[i]+1]+1):]\) が存在し
        \(\mathcal{sortedIndexOf}(s[(i+1):]) <
        \mathcal{sortedIndexOf}(s[(\mathcal{sa}^{-1}[i]+2):])\) から前項 (LCP の min 畳み込み)
        によって証明できます。<br />
      </p>

      <h4 id="ACL / Library Checker"><a href="#ACL / Library Checker">ACL / Library Checker</a></h4>
      <p>
        ユニークな部分列の数を数える問題です。ここでも suffix array 上で隣接する 2 項間の LCP
        間が最大であることを踏まえて、 \(\mathcal{sa}[i]\) と結合できる prefix (空でも良い)
        を重複無く数える式を考えると \(\sum\limits_i {(n - \mathcal{sa}[i] - \mathcal{lcp}[i])} =
        n^2 - \frac {n (n + 1)} {2} - \sum\limits_i \mathcal{lcp}[i]\) が導かれます。<br />
      </p>

      <p>
        なぜ \(\mathcal{lcp}[i]\) を引けば良いのか。それは suffix の prefix + 対象の prefix が他の
        prefix と一致することを避けるためのようです。この辺も難しい。。<br />
      </p>

      <ul>
        <li>
          <a href="https://atcoder.jp/contests/practice2/submissions/54548102"
            >ACL I - Number of Substrings (282 ms)</a
          ><br />
        </li>
        <li>
          <a href="https://judge.yosupo.jp/submission/215238"
            >Number of Substrings - Library Checker (203 ms)</a
          ><br />
        </li>
      </ul>

      <h3 id="感想"><a href="#感想">感想</a></h3>
      <p>
        <a href="https://atcoder.github.io/ac-library/production/document_ja/string.html">ACL</a>
        の文字列データ構造 (Z Funciton および Suffix Array)
        を実装しました。最大流とか遅延セグメント木に比べれば簡単な方ですが、使い方が見えない点が苦痛です。幸いプログラミングにおいては困難は実装せよで理解が進むため、なんとか喰らいつくことができました。<br />
      </p>

      <h2 id="Haskell"><a href="#Haskell">Haskell</a></h2>
      <h3 id="醜い Haskell のフォーマット">
        <a href="#醜い Haskell のフォーマット">醜い Haskell のフォーマット</a>
      </h3>
      <p>
        Z function の愚直実装は美しいフォーマットでした。 gksato さんの提出から学んだことですが、
        <strong><code>.</code> を使うとインデントが減ります</strong>:<br />
      </p>

      <div class="org-src-container">
        <pre><code class="src language-hs">saOfNaive :: BS.ByteString -&gt; U.Vector Int
saOfNaive bs =
  U.convert
    . V.map fst
    . V.modify (VAI.sortBy (comparing snd))
    $ V.generate n (\i -&gt; (i, BS.drop i bs))
  where
    n = BS.length bs
</code></pre>
      </div>

      <p>
        逆に <code>$</code> を使うと <code>ormolu</code> がインデントを重ねます。
        <code>$</code> を使ってダサくなりましょう:<br />
      </p>

      <div class="org-src-container">
        <label class="org-src-name"
          ><span class="listing-number">Listing 2: </span>ダサい Haskell</label
        >
        <pre><code class="src language-hs">saOfNaive :: BS.ByteString -&gt; U.Vector Int
saOfNaive bs =
  U.convert $
    V.map fst $
      V.modify (VAI.sortBy (comparing snd)) $
        V.generate n (\i -&gt; (i, BS.drop i bs))
  where
    n = BS.length bs
</code></pre>
      </div>

      <h3 id="QuickCheck alternatives?">
        <a href="#QuickCheck alternatives?">QuickCheck alternatives?</a>
      </h3>
      <p>
        今回の QuickCheck
        も、単なるランダムテストで愚直解と高速解を比較しています。ランダムではなく、小さい入力を全点チェックすれば良い
        (exhaustive test を実施すれば良い) 気もします。<br />
      </p>

      <ul>
        <li>
          肝心の <a href="https://github.com/Bodigrim/smallcheck">smallcheck</a> が obsolute
          となっていました。<br />
        </li>
        <li>
          <a href="https://hackage.haskell.org/package/falsify">falsify</a> は
          <code>smallcheck</code> の README からリンクされていますが、 exhausive test
          を強調していません。新しい仕組みをウリにしています。
          <code>tasty</code> 版はありません。<br />
        </li>
        <li>
          <a href="https://github.com/hedgehogqa/haskell-hedgehog">hedgehog</a> は quickcheck
          とほぼ同数の star を持つ歴史有りそうなライブラリで、
          <code>tasty-hedgehog</code> もあります。<br />
        </li>
      </ul>

      <p>これは QuickCheck 上で exhaustive test を実施する方法を調べたほうが良さそうです。<br /></p>

      <h2 id="Misc"><a href="#Misc">Misc</a></h2>
      <h3 id="nerd-icons.el">
        <a href="#nerd-icons.el"><code>nerd-icons.el</code></a>
      </h3>
      <p>
        Emacs ではアイコンレスなターミナル人生を歩んで来ましたが、
        <a href="https://github.com/rainstormstudio/nerd-icons.el">nerd-icons.el</a>
        により華やかになりました。この 1 週間、何度見ても嬉しいです。<br />
      </p>

      <figure>
        <img src="./img/2024-06-16-nerd-icons.png" alt="2024-06-16-nerd-icons.png" /><br />

        <figcaption><span class="figure-number">Figure 1: </span>my wife</figcaption>
      </figure>

      <p>
        <code>neotree</code> に関しては
        <a href="https://github.com/jaypei/emacs-neotree/pull/359">こちらの PR</a>
        がマージされれば、ほぼ out-of-the-box でアイコン表示できるようになるはずです。黄金期！ Emacs
        の時代は何度来ても良いですからね。<br />
      </p>

      <ul>
        <li><a href="https://github.com/rainstormstudio/nerd-icons.el">nerd-icons.el</a><br /></li>
        <li><a href="https://github.com/gekoke/magit-file-icons">magit-file-icons.el</a><br /></li>
      </ul>

      <h3 id="内なるクソリプの衝動"><a href="#内なるクソリプの衝動">内なるクソリプの衝動</a></h3>
      <p>X で Emacs の画像を送りつけてしまいました。しばらく控えます……<br /></p>

      <h3 id="AtCoder-JOI">
        <a href="#AtCoder-JOI"><a href="https://joi.goodbaton.com/">AtCoder-JOI</a></a>
      </h3>
      <p>
        半年間レーティングが上がらず苦しんでいます。過去のレーティングの上げ方はこんな感じです:<br />
      </p>

      <table>
        <colgroup>
          <col class="org-left" />

          <col class="org-left" />
        </colgroup>
        <thead>
          <tr>
            <th scope="col" class="org-left">レーティング</th>
            <th scope="col" class="org-left">レーティングを上げた (つもりの) 方法</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="org-left">灰色</td>
            <td class="org-left">典型 90 問の ★ 2, ★ 3 を解く</td>
          </tr>

          <tr>
            <td class="org-left">茶色</td>
            <td class="org-left">平日に問題を解く</td>
          </tr>

          <tr>
            <td class="org-left">緑色</td>
            <td class="org-left">水 diff を 100 問解く</td>
          </tr>
        </tbody>
      </table>

      <p>適切な時期に適切な問題を解くのが効く……と思いこんでいます。<br /></p>

      <blockquote>
        <p>人は自分の成長の因果関係を誤認識するそうなので、データ無き供述は情報量 0 です。<br /></p>
      </blockquote>

      <p>
        現在の僕は
        <strong>JOI の ★ 4 〜 ★ 6 を解くのが良い</strong>
        と助言を頂いたので、素直に取り組んでみます。ありがたい……！
        <a href="https://joi.goodbaton.com/">AtCoder-JOI</a> をあたります。<br />
      </p>

      <h3 id="oj t -M diff-all">
        <a href="#oj t -M diff-all"><code>oj t -M diff-all</code></a>
      </h3>
      <p>
        naoya さんの
        <a
          href="https://publish.obsidian.md/naoya/atcoder/ABC357+%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8A"
          >ABC357振り返り</a
        >
        で <code>oj</code> の side-by-side diff を知りました。 <del>ずるいや……！</del><br />
      </p>

      <p>Nix 上の環境構築を確認中……<br /></p>

      <h3 id="skk-tutorial">
        <a href="#skk-tutorial"><code>skk-tutorial</code></a>
      </h3>
      <p>
        日本語入力には、やはり
        <a href="https://ja.wikipedia.org/wiki/SKK">SKK</a> が良いらしいです。 macOS の方で
        <a href="https://ddskk.readthedocs.io/ja/latest/index.html">DDSKK</a> の
        <code>skk-tutorial</code> をやっています。 140 問くらいあるんですよね。<br />
      </p>

      <p>
        <a href="https://quruli.ivory.ne.jp/document/ddskk_14.2/skk_7.html"
          >Q3-4 左手の小指を SHIFT で酷使したくありません。</a
        ><br />
      </p>

      <p>
        これを見ると親指キーを SKK 専用のキーにするのが良いとあります。僕の
        <a href="https://shirogane-lab.net/items/64b7a006eb6dbe00346cd0c5">Keyball</a> には既に
        Enter キーや IME on, IME off が親指にあり、操作感を崩さずに移行するのが良さそうです。<br />
      </p>

      <h3 id="Misc of misc"><a href="#Misc of misc">Misc of misc</a></h3>
      <ul>
        <li>
          <a href="https://ncode.syosetu.com/n6093en/">危機感さん</a> アニメ化<br />
          めでたい 🎉<br />
        </li>

        <li>
          <a href="https://www.youtube.com/@YuyaMiyazaki_JP">宮崎雄也と音楽の話</a> 1,000 subscribes
          突破<br />
          めでたい 🎉<br />
        </li>

        <li>
          <a href="https://www.kickstarter.com/projects/noacat/elin">Elin</a> ベータテスト開始<br />
          めでたい 🎉<br />
        </li>
      </ul>
    </main>
    <footer role="contentinfo">
      <p>Styled with <a href="https://simplecss.org/">Simple.css</a></p>
      <div><a href="/index.html">Home</a><a href="https://github.com/toyboot4e">GitHub</a></div>
    </footer>
  </body>
</html>
