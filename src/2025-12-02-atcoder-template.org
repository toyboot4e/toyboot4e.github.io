#+TITLE: AtCoder ç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ç´¹ä»‹ (Haskell)
#+DATE: <2025-12-02 Tue>
#+FILETAGS: :atcoder:haskell:

ã“ã®è¨˜äº‹ã¯ [[https://qiita.com/advent-calendar/2025/haskell][Haskell Advent Calendar 2025]] ã® 2 æ—¥ç›®ã®æŠ•ç¨¿ã§ã™ã€‚

å‰å›ã®æŠ•ç¨¿ã¯ nobsun ã®ã€[[https://zenn.dev/nobsun/articles/previous-permutation][ç›´å‰ã®é †åˆ—]]ã€ã§ã—ãŸã€‚

* èƒŒæ™¯

** å‚åŠ è€…ã®æ¨ç§»

Haskell ã§ AtCoder ã‚’å§‹ã‚ã¦å››å¹´ç›®ã«ãªã‚Šã¾ã—ãŸã€‚ç¾åœ¨ã¯ã€æ¯é€±é–‹å‚¬ã®ã€AtCoder Beginner Contestã€ã«å‚åŠ ã™ã‚‹ Haskeller ã®æ•°ãŒ 10 åã‚’è¶…ãˆã¦ãŠã‚Šã€è‹¥å¹²ãƒ¡ãƒ³ãƒãƒ¼ãŒå…¥ã‚Œæ›¿ã‚ã‚Šã¤ã¤ã‚‚æœ€ç››æœŸã¨è¨€ãˆãã†ã§ã™ã€‚

** åƒ•ã®ç¾çŠ¶

åƒ•ã®æˆç¸¾ã®ãƒ”ãƒ¼ã‚¯ã¯ä¸€å¹´å‰ã§ã™ã€‚ä¸Šã‚’è¦‹ã¦ã„ãŸé ƒã¨æ¯”ã¹ã‚‹ã¨ã€æ®‹å¿µãªãŒã‚‰è…•å‰ã¯è½ã¡ã¦ã„ã¾ã™:

#+ATTR_HTML: :width 603px
[[./img/2025-12-02-graph.png]]

ã¨ã¯ã„ãˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¯ååˆ†ã«æ¯ã‚ŒãŸé ƒã§ã™ã®ã§ã€æ”¹ã‚ã¦ä¸»ãªãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

* ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç´¹ä»‹

åƒ•ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ [[https://github.com/toyboot4e/toy-lib][=toy-lib=]] ã§ã™ã€‚ AtCoder ã®æå‡ºã§ã¯ã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’å–ã‚Šå‡ºã—ã¦ =Main.hs= ã«å…¥ã‚Œã¦ã„ã¾ã™ (å¾Œè¿°ã® bundler) ã€‚

** =debug= ãƒ•ãƒ©ã‚°

AtCoder ç’°å¢ƒã§ã¯ç’°å¢ƒå¤‰æ•° =ATCODER= ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ =ATCODER= å®šç¾©ã®æœ‰ç„¡ã‚’åˆ¤å®šã—ã€ =debug= å¤‰æ•°ã«ä¿å­˜ã—ã¾ã™:

#+BEGIN_SRC hs
{-# LANGUAGE CPP #-}

import Debug.Trace

#ifdef ATCODER
debug :: Bool ; debug = False
#else
debug :: Bool ; debug = True
#endif
#+END_SRC

=debug= å¤‰æ•°ã‚’ä½¿ã£ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã®ã¿å‹•ä½œã™ã‚‹ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ç”¨ã®é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:

#+BEGIN_SRC hs
dbg :: (Show a) => a -> ()
dbg x
  | debug = let !_ = traceShow x () in ()
  | otherwise = ()

dbgId :: (Show a) => a -> a
dbgId x
  | debug = let !_ = traceShow x () in x
  | otherwise = x
#+END_SRC

#+BEGIN_QUOTE
æ­£æ ¼è©•ä¾¡ã¨ä½¿ã„æ–¹ã«ã¤ã„ã¦ã¯ [[https://zenn.dev/toyboot4e/books/seriously-haskell/viewer/2-1-stderr][[2-1] stderr ã«ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ï½œAtCoder ã‚¬ãƒè¨€èª Haskell ğŸ”¥]] ã‚’ã”å‚ç…§ãã ã•ã„ã€‚ã“ã®ç« ã¯ã¡ã‚ƒã‚“ã¨æ›¸ã„ã¦ã„ãŸã¯ãšâ€¦â€¦ã€‚
#+END_QUOTE

** ç´¯ç©å’Œã€åŒºé–“å’Œ

ç´¯ç©å’Œ (prefix sum) ã‚’äº‹å‰è¨ˆç®—ã—ã¦ãŠãã¨ã€ $[l, r]$ åŒºé–“ã®å’Œã‚’ $S[r + 1] - S[l]$ ã«ã‚ˆã‚Š $O(1)$ ã§è¨ˆç®—ã§ãã¾ã™ã€‚ã“ã®åŒºé–“å’Œã®è¨ˆç®—ã‚’ =(+!)= æ¼”ç®—å­ã«ã—ã¦ã„ã¾ã™:

#+BEGIN_SRC hs
import Data.Vector.Generic qualified as G
import Data.Vector.Unboxed qualified as U
import GHC.Stack (HasCallStack)

{-# INLINE csum1D #-}
csum1D :: (Num a, U.Unbox a) => U.Vector a -> U.Vector a
csum1D = U.scanl' (+) 0

{-# INLINE (+!) #-}
(+!) :: (HasCallStack, Num a, U.Unbox a) => U.Vector a -> (Int, Int) -> a
(+!) csum (!l, !r) = csum G.! (r + 1) - csum G.! l -- (ref:1)
#+END_SRC

- [[(1)]] =vector= ã§ã¯ =Data.Vector.Generic= ã«ã®ã¿ =HasCallStack= åˆ¶ç´„ãŒã¤ã„ã¦ã„ã‚‹ãŸã‚ã€ =G.!= ã‚’ä½¿ã£ãŸæ–¹ãŒè‰¯ã„ã§ã™

** =index'=

[[https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ix.html#v:index][=Data.Ix.index=]] ã«ã¯ [[https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Stack.html#t:HasCallStack][=HasCallStack=]] åˆ¶ç´„ãŒç„¡ã„ãŸã‚ã€ã‚¨ãƒ©ãƒ¼æ™‚ã®æƒ…å ±ã«ä¹ã—ã„ã§ã™ã€‚ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:

#+BEGIN_SRC txt
a-exe: Error in array index
#+END_SRC

ã‚ˆã‚Šè©³ç´°ãªã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’ã—ã¦ãã‚Œã‚‹ =index= é–¢æ•°ã¯ä»¥ä¸‹ã¨ãªã‚Šã¾ã™:

#+BEGIN_SRC hs
import Data.Ix
import GHC.Stack (HasCallStack)

{-# INLINE index' #-}
index' :: (HasCallStack, Ix i, Show i) => (i, i) -> i -> Int
index' !bnd !i
  | inRange bnd i = index bnd i
  | otherwise = error $ "index out ouf bounds: " ++ show i ++ " in " ++ show bnd
#+END_SRC

æ¬¡ã®ã‚ˆã†ã«è¡¨ç¤ºã—ã¦ãã‚Œã¦åŠ©ã‹ã‚Šã¾ã™:

#+BEGIN_SRC txt
a-exe: index out ouf bounds: (-1,-1) in ((0,0),(4,4))
CallStack (from HasCallStack):
  error, called at src/Data/Vector/IxVector.hs:30:17 in toy-lib-0.1.0.0-inplace:Data.Vector.IxVector
  index', called at a/Main.hs:35:12 in abc434-0.1.0.0-inplace-a-exe:Main
#+END_SRC

** 2 æ¬¡å…ƒ or 3 æ¬¡å…ƒ vector

[[https://hackage.haskell.org/package/vector][=vector=]] ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ 1 æ¬¡å…ƒé…åˆ—ã‚’æä¾›ã—ã¾ã™ã€‚ =vector= ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ã¨ã€ [[https://zenn.dev/naoya_ito/articles/87a8a21d52c302][=array=]] ä¼¼ã®å¤šæ¬¡å…ƒé…åˆ—ã® API ã‚’æä¾›ã§ãã¾ã™ã€‚

#+BEGIN_SRC hs
import Control.Monad.Primitive
import Data.Ix
import Data.Vector.Generic qualified as G
import Data.Vector.Unboxed qualified as U
import GHC.Stack (HasCallStack)

data IxVector i v = IxVector {boundsIV :: !(i, i), vecIV :: !v}
  deriving (Show, Eq)

-- Immutable ãª IxVector ã®å€¤ã‚’èª­ã‚€
{-# INLINE (@!) #-}
(@!) :: (HasCallStack, Ix i, Show i, G.Vector v a) => IxVector i (v a) -> i -> a
(@!) IxVector {..} i = vecIV G.! index' boundsIV i

-- Mutable ãª IxVector ã®å€¤ã‚’èª­ã‚€
{-# INLINE readIV #-}
readIV :: (HasCallStack, Ix i, Show i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a
readIV IxVector {..} i = GM.read vecIV (index' boundsIV i)
#+END_SRC

è¡Œåˆ—ã‚„ã‚°ãƒªãƒƒãƒ‰ã®èª­ã¿è¾¼ã¿ã§ã‚‚ã€ä¸Šè¨˜ã® =IxVector= å‹ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ (å¾Œè¿°):

#+BEGIN_SRC hs
matP :: (MonadState BS.ByteString m) => Int -> Int -> m (IxVector (Int, Int) (U.Vector Int))
matP h w = IxVector ((0, 0), (h - 1, w - 1)) <$> U.replicateM (h * w) intP

gridP :: (MonadState BS.ByteString m) => Int -> Int -> m (IxVector (Int, Int) (U.Vector Char))
gridP h w = IxVector ((0, 0), (h - 1, w - 1)) <$> U.replicateM (h * w) charP
#+END_SRC

å®Œå…¨ã«ã‚¬ãƒ©ãƒ‘ã‚´ã‚¹ãªã®ãŒç ã«ç‘•ã§ã™ãŒã€ [[https://hackage.haskell.org/package/massiv][=massiv=]] ã¨æ¯”è¼ƒã—ã¦è»½é‡ã§ç„¡é›£ãªé¸æŠè‚¢ã ã¨æ€ã„ã¾ã™ã€‚

** ã‚¹ãƒ‹ãƒšãƒƒãƒˆ

=err= ã‚’ =error "unreachable"= ã«å±•é–‹ã™ã‚‹ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ã¾ãŸ =inl= ã‚’ ={-# INLINE _ #-}= ã«å±•é–‹ã™ã‚‹ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚‚ä½¿ã£ã¦ã„ã¾ã™ã€‚

ãã®ä»–ã¯å…¨ã¦æ‰‹æ‰“ã¡ã§ã™ãŒã€ =->= ã‚’ç°¡å˜ã« (è‡ªå‹•çš„ã«) å…¥åŠ›ã—ã¦ãã‚Œã‚‹ä»•çµ„ã¿ãŒå¿…è¦ã ã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚

** å…¥åŠ›

æ¨™æº–å…¥åŠ›ã¯ã€æ¦‚ã­ä»¥ä¸‹ã®ã‚ˆã†ã«èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™:

#+BEGIN_SRC hs
import Control.Monad.State.Class
import Control.Monad.State.Strict
import Data.ByteString.Char8 qualified as BS
import Data.Maybe (fromJust)

{-# INLINE intP #-}
intP :: (MonadState BS.ByteString m) => m Int
intP = state $ fromJust . BS.readInt . BS.dropSpace -- (ref:1)

ints2P :: (MonadState BS.ByteString m) => m (Int, Int)
ints2P = (,) <$> intP <*> intP -- (ref:2)

solve :: StateT BS.ByteString IO () -- (ref:3)
solve = do
  (!a, !b) <- ints2P
  -- ..

main :: IO ()
main = evalStateT solve =<< BS.getContents -- (ref:4)
#+END_SRC

- [[(1)]] =BS.readInt= ãªã©ã¯ =State= ãƒ¢ãƒŠãƒ‰ã§åŒ…ã¿ç›´ã—ã¦ã„ã¾ã™
- [[(2)]] ãƒ‘ãƒ¼ã‚µã‚’å…ƒã«åˆ¥ã®ãƒ‘ãƒ¼ã‚µã‚’ä½œã‚Šã¾ã™
- [[(3)]] è§£ç­”ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å‹ã¯ =StateT BS.ByteString IO ()= ã§ã™
- [[(4)]] è§£ç­”ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®çŠ¶æ…‹ã«æ¨™æº–å…¥åŠ›å…¨ä½“ã‚’æ¸¡ã—ã¦ã„ã¾ã™

*** =State= ãƒ¢ãƒŠãƒ‰ã®æœ‰ç”¨æ€§

=State= ãƒ¢ãƒŠãƒ‰ç„¡ã—ã§ãƒ‘ãƒ¼ã‚µã‚’å®šç¾©ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«çŠ¶æ…‹ã‚’å¼•ãå›ã™ã“ã¨ã«ãªã£ã¦å¤§å¤‰ã§ã™:

#+BEGIN_SRC hs
import Data.ByteString.Char8 qualified as BS
import Data.Maybe (fromJust)

{-# INLINE ints2 #-}
ints2 :: BS.ByteString -> ((Int, Int), BS.ByteString)
ints2 bs0 =
  let (i1, bs1) = fromJust . BS.readInt $ BS.dropSpace bs0
      (i2, bs2) = fromJust . BS.readInt $ BS.dropSpace bs1
   in ((i1, i2), bs2)
#+END_SRC

*** ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å•é¡Œã®å ´åˆ

ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å•é¡Œã§ =BS.getContents= ã‚’å‘¼ã¶ã¨ã€æ°¸ä¹…ã«åˆ¶å¾¡ãŒå¸°ã£ã¦ã“ãªããªã‚Šã¾ã™ã€‚ã—ãŸãŒã£ã¦ =BS.getLine= ã§èª­ã¿è¾¼ã‚“ã å„è¡Œã«å¯¾ã—ã¦ãƒ‘ãƒ¼ã‚µã‚’é©ç”¨ã—ã¦ã„ã¾ã™ã€‚

ãƒ˜ãƒ«ãƒ‘é–¢æ•°ã® =withLine= ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:

#+BEGIN_SRC hs
{-# INLINE withLine #-}
withLine :: (MonadIO m) => State BS.ByteString a -> m a
withLine f = evalState f <$> liftIO BS.getLine

main :: IO ()
main = do
  (a, b) <- withLine ints2P
  -- ..
#+END_SRC

ã“ã®è¾ºã‚Šã¯ [[https://booth.pm/ja/items/1577541][Haskellã§æˆ¦ã†ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ç¬¬2ç‰ˆ]] ã§ã‚‚è§¦ã‚Œã‚‰ã‚Œã¦ã„ãŸã‚ˆã†ã«æ€ã„ã¾ã™ã€‚ãƒã‚¤ãƒ–ãƒ«ã§ã™ã­ã€‚

ãã®ä»–ã€è©³ã—ãã¯ [[https://zenn.dev/toyboot4e/books/kyopro-bonsai-hs/viewer/parser][State ãƒ™ãƒ¼ã‚¹ã®ãƒ‘ãƒ¼ã‚µï½œç«¶ãƒ—ãƒ­ç›†æ ½.hs]] ã§è§£èª¬ã—ã¦ã„ã¾ã™ã€‚ã‚ã¡ã‚‰ã§ã¯ãƒ‘ãƒ¼ã‚µãŒ =Maybe BS.ByteString= ã‚’è¿”ã™ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

** å‡ºåŠ›

æ¨™æº–å‡ºåŠ›ã«ã¯ [[https://hackage-content.haskell.org/package/bytestring-0.12.2.0/docs/Data-ByteString-Builder.html][Data.ByteString.Builder]] ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚æ–‡å­—åˆ—ã‚’è²ªæ¬²ã«çµåˆã™ã‚‹ã¨ $O(|S|^2)$ ã®å‡¦ç†ã«ãªã‚Šã¾ã™ãŒã€ =Builder= ã¯æ¦‚ã­é€£çµãƒªã‚¹ãƒˆã‚‰ã—ãã€ $O(|S|)$ ã§å‡ºåŠ›ã§ãã¾ã™ã€‚

=Builder= ã«å¤‰æ›ã™ã‚‹ãŸã‚ã®å‹ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã¾ã™:

#+BEGIN_SRC hs
class ShowBSB a where
  showBSB :: a -> BSB.Builder
  {-# INLINE showBSB #-}
  default showBSB :: (Show a) => a -> BSB.Builder
  showBSB = BSB.string8 . show

instance ShowBSB Int where
  {-# INLINE showBSB #-}
  showBSB = BSB.intDec

instance ShowBSB Double where
  {-# INLINE showBSB #-}
  showBSB = BSB.doubleDec

-- ..
#+END_SRC

ã“ã‚Œã‚’ä½¿ã£ã¦ã€ä½•ã§ã‚‚ =printBSB= ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™:

#+BEGIN_SRC hs
{-# INLINE putLnBSB #-}
putLnBSB :: (MonadIO m) => BSB.Builder -> m ()
putLnBSB = liftIO . BSB.hPutBuilder stdout . (<> endlBSB)

{-# INLINE showLnBSB #-}
showLnBSB :: (ShowBSB a) => a -> BSB.Builder
showLnBSB = (<> endlBSB) . showBSB

{-# INLINE printBSB #-}
printBSB :: (ShowBSB a, MonadIO m) => a -> m ()
printBSB = putBSB . showLnBSB
#+END_SRC

** Bundler ã«ã¤ã„ã¦

å·¨å¤§ãªæå‡ºãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã‹ã‚‰ã€å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã¿ã‚’æå‡ºãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã‚ãŸã„ã‚‚ã®ã§ã™ã€‚ =toy-lib= ã¯ã“ã®ã‚ˆã†ãª bundler ã®æ©Ÿèƒ½ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

*** ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼

ä¾‹ãˆã°ä»¥ä¸‹ã® =Main.hs= ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã¨ã—ã¾ã™:

#+BEGIN_SRC hs
-- {{{ toy-lib import
import ToyLib.Prelude
-- }}} toy-lib import

main :: IO ()
main = putStrLn "Hello, world!"
#+END_SRC

*** Bundling ã®å®Ÿæ–½

ã“ã‚Œã‚’ =toy-lib= (å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«) ã«ã‹ã‘ã‚‹ã¨ã€ =import ToyLib.Prelude= ã®éƒ¨åˆ†ãŒ =src/ToyLib/Prelude.hs= ãŠã‚ˆã³ =Prelude.hs= ã®ä¾å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã«ç½®æ›ã•ã‚Œã¾ã™:

#+BEGIN_SRC sh
$ toy-lib -e Main.hs > Main2.hs
embedding the following toy-lib source files:
- Data/Core/Unindex.hs
- ToyLib/Prelude.hs
#+END_SRC

ç½®æ›å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã¯æ¬¡ã®é€šã‚Šã§ã™:

#+BEGIN_SRC hs
$ cat Main2.hs
class (Ix i, U.Unbox i) => Unindex i where { unindex :: (i, i) -> Int -> i};instance Unindex Int where { {-# INLINE unindex #-}; unindex _ !v = v};instance Unindex (Int, Int) where { {-# INLINE unindex #-}; unindex ((!y0, !x0), (!_, !x1)) !yx = let { !w = x1 - x0 + 1; (!dy, !dx) = yx `quotRem` w} in (y0 + dy, x0 + dx)};instance Unindex (Int, Int, Int) where { {-# INLINE unindex #-}; unindex ((!z0, !y0, !x0), (!_, !y1, !x1)) !zyx = let { !h = y1 - y0 + 1; !w = x1 - x0 + 1; (!dz, !yx) = zyx `quotRem` (h * w); (!dy, !dx) = yx `quotRem` w} in (z0 + dz, y0 + dy, x0 + dx)};instance Unindex (Int, Int, Int, Int) where { {-# INLINE unindex #-}; unindex ((!b3, !b2, !b1, !b0), (!_, !x2, !x1, !x0)) !pos3 = let { !w2 = x2 - b2 + 1; !w1 = x1 - b1 + 1; !w0 = x0 - b0 + 1; (!y3, !pos2) = pos3 `quotRem` (w2 * w1 * w0); (!y2, !pos1) = pos2 `quotRem` (w1 * w0); (!y1, !y0) = pos1 `quotRem` w0} in (b3 + y3, b2 + y2, b1 + y1, b0 + y0)};instance Unindex ((Int, Int), (Int, Int)) where { {-# INLINE unindex #-}; unindex (((!b3, !b2), (!b1, !b0)), ((!_, !x2), (!x1, !x0))) !pos3 = let { !w2 = x2 - b2 + 1; !w1 = x1 - b1 + 1; !w0 = x0 - b0 + 1; (!y3, !pos2) = pos3 `quotRem` (w2 * w1 * w0); (!y2, !pos1) = pos2 `quotRem` (w1 * w0); (!y1, !y0) = pos1 `quotRem` w0} in ((b3 + y3, b2 + y2), (b1 + y1, b0 + y0))};{-# INLINE rleOf #-};rleOf :: BS.ByteString -> [(Char, Int)];rleOf = map (\ s -> (BS.head s, BS.length s)) . BS.group;{-# INLINE rleOfU #-};rleOfU :: BS.ByteString -> U.Vector (Char, Int);rleOfU = U.fromList . rleOf;{-# INLINE square #-};square :: (Num a) => a -> a;square !x = x * x;{-# INLINE isqrt #-};isqrt :: Int -> Int;isqrt = round @Double . sqrt . fromIntegral;{-# INLINE (.:) #-};(.:) :: (b -> c) -> (a1 -> a2 -> b) -> (a1 -> a2 -> c);(.:) = (.) . (.);{-# INLINE swapDupeU #-};swapDupeU :: U.Vector (Int, Int) -> U.Vector (Int, Int);swapDupeU = U.concatMap (\ (!u, !v) -> U.fromListN 2 [(u, v), (v, u)]);{-# INLINE swapDupeW #-};swapDupeW :: (U.Unbox w) => U.Vector (Int, Int, w) -> U.Vector (Int, Int, w);swapDupeW = U.concatMap (\ (!u, !v, !d) -> U.fromListN 2 [(u, v, d), (v, u, d)]);{-# INLINE ortho4 #-};ortho4 :: U.Vector (Int, Int);ortho4 = U.fromList [(0, 1), (0, -1), (1, 0), (-1, 0)];{-# INLINE ortho4' #-};ortho4' :: ((Int, Int), (Int, Int)) -> (Int, Int) -> U.Vector (Int, Int);ortho4' bnd base = U.filter (inRange bnd) $ U.map (add2 base) ortho4;{-# INLINE orthoWith #-};orthoWith :: ((Int, Int), (Int, Int)) -> ((Int, Int) -> Bool) -> (Int -> U.Vector Int);orthoWith bnd p v1 = U.map (index bnd) . U.filter ((&&) <$> inRange bnd <*> p) $ U.map (add2 (unindex bnd v1)) ortho4;{-# INLINE diag4 #-};diag4 :: U.Vector (Int, Int);diag4 = U.fromList [(-1, 1), (1, 1), (1, -1), (-1, -1)];{-# INLINE slice #-};slice :: (G.Vector v a) => Int -> Int -> v a -> v a;slice !l !r !vec = G.slice l (max 0 (r - l + 1)) vec;{-# INLINE zero2 #-};zero2 :: Int -> Int -> ((Int, Int), (Int, Int));zero2 n1 n2 = ((0, 0), (n1 - 1, n2 - 1));{-# INLINE zero3 #-};zero3 :: Int -> Int -> Int -> ((Int, Int, Int), (Int, Int, Int));zero3 n1 n2 n3 = ((0, 0, 0), (n1 - 1, n2 - 1, n3 - 1));{-# INLINE rangeG #-};rangeG :: (G.Vector v Int) => Int -> Int -> v Int;rangeG !i !j = G.enumFromN i (succ j - i);{-# INLINE rangeV #-};rangeV :: Int -> Int -> V.Vector Int;rangeV = rangeG;{-# INLINE rangeU #-};rangeU :: Int -> Int -> U.Vector Int;rangeU = rangeG;{-# INLINE rangeGR #-};rangeGR :: (G.Vector v Int) => Int -> Int -> v Int;rangeGR !i !j = G.enumFromStepN j (-1) (succ j - i);{-# INLINE rangeVR #-};rangeVR :: Int -> Int -> V.Vector Int;rangeVR = rangeGR;{-# INLINE rangeUR #-};rangeUR :: Int -> Int -> U.Vector Int;rangeUR = rangeGR;{-# INLINE times #-};times :: Int -> (a -> a) -> a -> a;times !n !f = inner 0 where { inner i !s | i >= n = s | otherwise = inner (i + 1) $! f s};interleave :: [a] -> [a] -> [a];interleave xs [] = xs; interleave [] ys = ys; interleave (x : xs) (y : ys) = x : y : interleave xs ys;combs :: Int -> [a] -> [[a]];combs _ [] = []; combs k as@(!(_ : xs)) | k == 0 = [[]] | k == 1 = map pure as | k == l = pure as | k > l = [] | otherwise = run (l - 1) (k - 1) as $ combs (k - 1) xs where { l = length as; run :: Int -> Int -> [a] -> [[a]] -> [[a]]; run n k ys cs | n == k = map (ys ++) cs | otherwise = map (q :) cs ++ run (n - 1) k qs (drop dc cs) where { (!(q : qs)) = take (n - k + 1) ys; dc = product [(n - k + 1) .. (n - 1)] `div` product [1 .. (k - 1)]}};{-# INLINE swapDupe #-};swapDupe :: (a, a) -> [(a, a)];swapDupe (!x1, !x2) = [(x1, x2), (x2, x1)];{-# INLINE add2 #-};add2 :: (Int, Int) -> (Int, Int) -> (Int, Int);add2 (!y, !x) = bimap (y +) (x +);{-# INLINE sub2 #-};sub2 :: (Int, Int) -> (Int, Int) -> (Int, Int);sub2 (!y, !x) = bimap (y -) (x -);{-# INLINE mul2 #-};mul2 :: Int -> (Int, Int) -> (Int, Int);mul2 !m = both (m *);{-# INLINE add3 #-};add3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);add3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 + z2, y1 + y2, x1 + x2);{-# INLINE sub3 #-};sub3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);sub3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 - z2, y1 - y2, x1 - x2);{-# INLINE mul3 #-};mul3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);mul3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 - z2, y1 - y2, x1 - x2);{-# INLINE toRadian #-};toRadian :: Double -> Double;toRadian degree = degree / 180.0 * pi;{-# INLINE toDegree #-};toDegree :: Double -> Double;toDegree rad = rad / pi * 180.0;{-# INLINE fst4 #-};fst4 :: (a, b, c, d) -> a;fst4 (!a, !_, !_, !_) = a;{-# INLINE snd4 #-};snd4 :: (a, b, c, d) -> b;snd4 (!_, !b, !_, !_) = b;{-# INLINE thd4 #-};thd4 :: (a, b, c, d) -> c;thd4 (!_, !_, !c, !_) = c;{-# INLINE fth4 #-};fth4 :: (a, b, c, d) -> d;fth4 (!_, !_, !_, !d) = d;{-# INLINE first4 #-};first4 :: (a -> x) -> (a, b, c, d) -> (x, b, c, d);first4 f (!a, !b, !c, !d) = (f a, b, c, d);{-# INLINE second4 #-};second4 :: (b -> x) -> (a, b, c, d) -> (a, x, c, d);second4 f (!a, !b, !c, !d) = (a, f b, c, d);{-# INLINE third4 #-};third4 :: (c -> x) -> (a, b, c, d) -> (a, b, x, d);third4 f (!a, !b, !c, !d) = (a, b, f c, d);{-# INLINE fourth4 #-};fourth4 :: (d -> x) -> (a, b, c, d) -> (a, b, c, x);fourth4 f (!a, !b, !c, !d) = (a, b, c, f d);fix1 :: a -> ((a -> b) -> a -> b) -> b;fix1 a f = fix f a;fix2 :: a -> b -> ((a -> b -> c) -> a -> b -> c) -> c;fix2 a b f = fix f a b;fix3 :: a -> b -> c -> ((a -> b -> c -> d) -> a -> b -> c -> d) -> d;fix3 a b c f = fix f a b c

main :: IO ()
main = putStrLn "Hello, world!"
#+END_SRC

ç½®æ›å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ AtCoder ã«æå‡ºã—ã¦ã„ã¾ã™ ([[https://atcoder.jp/contests/abc434/submissions/71359707][ä¾‹]]) ã€‚

*** Bundler ã®å®Ÿè£…æ–¹æ³•

ç¾åœ¨ã¯ Haskeller å‘ã‘ã®æ±ç”¨ã® bundler ãŒç„¡ã„ã‚ˆã†ã«æ€ã„ã¾ã™ã€‚ä½œã£ã¦ã„ãªãã¦ã™ã¿ã¾ã›ã‚“ã€‚

æ°—ã«ãªã‚‹æ–¹ã¯ [[https://github.com/toyboot4e/toy-lib][=toy-lib=]] ã® =app= ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç­‰ã‚’ã”å‚ç…§ãã ã•ã„ã€‚ã¾ãŸä¸Šã®ä¾‹ã®ã‚ˆã†ã«ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ 1 è¡Œã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ãªãã¦è‰¯ã„å ´åˆã«ã¯ã€ =@cojna= ã•ã‚“ã® [[https://github.com/cojna/iota][=iota=]] ã‚’ã”è¦§ãã ã•ã„ã€‚

** ac-library-hs

ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å¤§åŠã‚’ [[https://hackage.haskell.org/package/ac-library-hs][ac-library-hs]] ã«ç§»è¡Œã—ãŸãŸã‚ã€ =import= ã—ã¦ä½¿ã£ã¦ã„ã¾ã™ã€‚

* ã¾ã¨ã‚

AtCoder ç”¨ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚æ•°å¹´å‰ã®æŠ•ç¨¿ã‹ã‚‰ãã“ã¾ã§å¤‰ã‚ã£ã¦ãŠã‚‰ãšã€ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ã€å¤šæ¬¡å…ƒé…åˆ—ã€å…¥å‡ºåŠ›ãŒã‚ã‚Œã°æ¦‚ã­ååˆ†ãªæ°—ãŒã—ã¾ã™ã€‚

ç¾åœ¨ã®ã‚¹ã‚¿ã‚¤ãƒ«ãŒå®‰å®šã™ã‚‹ã¾ã§ã«ã€ä¸»ã«ä»¥ä¸‹ã®æœ¬ãƒ»ãƒªãƒã‚¸ãƒˆãƒªã‹ã‚‰å½±éŸ¿ã‚’å—ã‘ã¾ã—ãŸã€‚ã„ã¤ã‚‚ãŠä¸–è©±ã«ãªã£ã¦ã„ã¾ã™:

- [[https://booth.pm/ja/items/1577541][Haskellã§æˆ¦ã†ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚° ç¬¬2ç‰ˆ]]
- [[https://github.com/cojna/iota][cojna/iota]]

-----

æ˜æ—¥ã®æŠ•ç¨¿ã¯ mr\under{}konn ã•ã‚“ã®ã€Haskellerã¨RustaceanãŒçŸ¥æµã‚’ã‚ã‚ã›ã¦ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚’3æ—¥ã§1000å€é«˜é€ŸåŒ–ã—ãŸè©±ã€ã§ã™ã€‚ä»Šå¹´ã‚‚è¶…å¤§ä½œãªã®ã§ã—ã‚‡ã†ã‹ã€‚æ¥½ã—ã¿ã§ã™ï¼

